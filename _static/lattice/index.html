<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Lattice Simulator</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  
<script type="module">
import init, * as bindings from './lattice-gol-e0c084340bc88988.js';
const wasm = await init({ module_or_path: './lattice-gol-e0c084340bc88988_bg.wasm' });


window.wasmBindings = bindings;


dispatchEvent(new CustomEvent("TrunkApplicationStarted", {detail: {wasm}}));

</script>
  
  
  <style>
    body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #050505;
      font-family: 'Inter', sans-serif;
      color: #eee;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Sidebar Layout */
    #sidebar-container {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      width: 320px;
      /* Default width */
      display: flex;
      flex-direction: column;
      z-index: 20;
      transition: transform 0.3s ease;
      background: rgba(20, 20, 20, 0.95);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }

    #sidebar-container.collapsed {
      transform: translateX(320px);
    }

    #sidebar-header {
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 16px;
      background: rgba(255, 255, 255, 0.03);
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    #sidebar-title {
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.5px;
      color: #eee;
    }

    #sidebar-toggle {
      position: absolute;
      left: -32px;
      top: 12px;
      width: 32px;
      height: 32px;
      background: rgba(20, 20, 20, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-right: none;
      border-radius: 8px 0 0 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #ccc;
    }

    #sidebar-toggle:hover {
      color: #fff;
      background: rgba(40, 40, 40, 0.9);
    }

    #sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      scrollbar-width: thin;
      scrollbar-color: #444 transparent;
      min-height: 0;
      /* Important for flex scrolling */
    }

    #sidebar-content::-webkit-scrollbar {
      width: 6px;
    }

    #sidebar-content::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 3px;
    }

    /* Panels (formerly windows) */
    .panel {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      transition: box-shadow 0.2s;
      flex-shrink: 0;
      /* Prevent shrinking, force scroll */
    }

    .panel-header {
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.02);
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
    }

    .panel-header h3 {
      margin: 0;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.5px;
      opacity: 0.9;
    }

    .panel-controls {
      display: flex;
      gap: 4px;
    }

    .header-btn {
      background: transparent;
      border: none;
      color: #888;
      cursor: pointer;
      padding: 2px;
      font-size: 14px;
      border-radius: 4px;
    }

    .header-btn:hover {
      color: #fff;
      background: rgba(255, 255, 255, 0.1);
    }

    .panel-body {
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .section-title {
      font-size: 11px;
      font-weight: 600;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
      padding-bottom: 4px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    label {
      font-size: 12px;
      color: #aaa;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .space-between {
      justify-content: space-between;
    }

    select,
    input[type="number"],
    input[type="range"] {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #fff;
      padding: 6px 10px;
      border-radius: 6px;
      font-family: inherit;
      font-size: 13px;
      outline: none;
    }

    select {
      width: 100%;
      cursor: pointer;
    }

    input[type="number"] {
      width: 60px;
    }

    input[type="range"] {
      flex: 1;
      cursor: pointer;
    }

    button {
      background: #3a86ff;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: background 0.2s;
      flex: 1;
    }

    button:hover {
      background: #2671eb;
    }

    button.secondary {
      background: rgba(255, 255, 255, 0.1);
    }

    button.secondary:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .bit-check {
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
      cursor: pointer;
      padding: 2px;
      user-select: none;
    }

    .bit-check input {
      display: none;
    }

    .bit-check span {
      font-size: 10px;
      color: #666;
      font-weight: bold;
    }

    .bit-check input:checked+span {
      color: #fff;
    }

    .bit-check:has(input:checked) {
      background: #3a86ff;
    }


    .section-content {
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
  </style>
<link rel="modulepreload" href="./lattice-gol-e0c084340bc88988.js" crossorigin="anonymous" integrity="sha384-gZdaoop8Lnv6Cc2Sj6Ie3F/ohz9if22oWYKcGFHjTpB+omLUr7Yk6LGU3H69lyxG"><link rel="preload" href="./lattice-gol-e0c084340bc88988_bg.wasm" crossorigin="anonymous" integrity="sha384-Nvv3vijzm7s7Y0lT7h4gFy2qVLi1mjjCcozDLaDlkzwxghBmnYAuOZqyz7im0P/k" as="fetch" type="application/wasm"></head>

<body>
  <canvas id="game-of-life-canvas"></canvas>

  <!-- Sidebar Container -->
  <div id="sidebar-container">
    <button id="sidebar-toggle">☰</button>
    <div id="sidebar-header">
      <span id="sidebar-title">Settings</span>
    </div>
    <div id="sidebar-content">

      <!-- 1. Main Control -->
      <div id="panel-main" class="panel">
        <div class="panel-header">
          <h3>Main Control</h3>
        </div>
        <div class="panel-body">
          <!-- Measurements -->
          <div>
            <div class="section-title">Measurements</div>
            <div id="measurements-grid"
              style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px; color: #888;">
              <div>Dens: <span id="meas-density" style="color:#eee">0.00</span></div>
              <div>Mag: <span id="meas-mag" style="color:#eee">0.00</span></div>
              <div>Energy: <span id="meas-energy" style="color:#eee">0.00</span></div>
              <div>FPS: <span id="meas-fps" style="color:#eee">60</span></div>
            </div>
          </div>
          <!-- Simulation Control -->
          <div class="control-group">
            <div class="row space-between">
              <label>Speed</label>
              <input type="range" id="speed-slider" min="1" max="60" value="60">
            </div>
          </div>
          <div class="row" style="margin-top: 4px; padding: 0 4px;">
            <button id="play-pause">Pause</button>
            <button id="step-btn" class="secondary">Step</button>
            <button id="reset-btn" class="secondary">Reset</button>
          </div>
        </div>
      </div>

      <!-- 2. Ising Control -->
      <div id="panel-ising" class="panel">
        <div class="panel-header">
          <h3>Ising Model</h3>
        </div>
        <div class="panel-body">
          <!-- Async Update (Ising) -->
          <div class="row">
            <input type="checkbox" id="async-enabled" checked>
            <label for="async-enabled" style="color: #fff;">Enable Async Update</label>
          </div>
          <div id="async-controls">
            <div class="row space-between">
              <label>Temp (T)</label>
              <input type="number" id="ising-temp" step="0.1" value="2.27" style="width: 50px;">
            </div>
            <input type="range" id="ising-temp-range" min="0.1" max="5.0" step="0.01" value="2.27">

            <div class="row space-between" style="margin-top: 4px;">
              <label>Field (h)</label>
              <input type="number" id="ising-h" step="0.1" value="0.0" style="width: 50px;">
            </div>
            <input type="range" id="ising-h-range" min="-2.0" max="2.0" step="0.01" value="0.0">

            <div class="row space-between" style="margin-top: 4px;">
              <label>Coupling (J)</label>
              <input type="number" id="ising-j" step="0.1" value="1.0" style="width: 50px;">
            </div>
            <input type="range" id="ising-j-range" min="-2.0" max="2.0" step="0.01" value="1.0">

            <div class="row space-between" style="margin-top: 8px;">
              <label>Sweeps/Frame</label>
              <input type="number" id="async-rate-num" step="0.1" value="1.0" style="width: 50px;">
            </div>
            <input type="range" id="async-rate" min="0.0" max="2.0" step="0.1" value="1.0">
          </div>
        </div>
      </div>

      <!-- 3. GoL Control -->
      <div id="panel-gol" class="panel">
        <div class="panel-header">
          <h3>Game of Life</h3>
        </div>
        <div class="panel-body">
          <!-- Sync Update (GoL) -->
          <div class="row">
            <input type="checkbox" id="sync-enabled">
            <label for="sync-enabled" style="color: #fff;">Enable Sync Update</label>
          </div>
          <div id="sync-controls">
            <div style="display: flex; gap: 12px;">
              <!-- Birth Rules -->
              <div style="flex: 1;">
                <div style="font-size: 10px; margin-bottom: 4px; color: #888;">BIRTH</div>
                <div class="bitmask-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px;">
                  <!-- Logic 0-8 -->
                  <label class="bit-check" title="0"><input type="checkbox" id="gol-b0"><span>0</span></label>
                  <label class="bit-check" title="1"><input type="checkbox" id="gol-b1"><span>1</span></label>
                  <label class="bit-check" title="2"><input type="checkbox" id="gol-b2"><span>2</span></label>
                  <label class="bit-check" title="3"><input type="checkbox" id="gol-b3" checked><span>3</span></label>
                  <label class="bit-check" title="4"><input type="checkbox" id="gol-b4"><span>4</span></label>
                  <label class="bit-check" title="5"><input type="checkbox" id="gol-b5"><span>5</span></label>
                  <label class="bit-check" title="6"><input type="checkbox" id="gol-b6"><span>6</span></label>
                  <label class="bit-check" title="7"><input type="checkbox" id="gol-b7"><span>7</span></label>
                  <label class="bit-check" title="8"><input type="checkbox" id="gol-b8"><span>8</span></label>
                </div>
              </div>
              <!-- Survival Rules -->
              <div style="flex: 1;">
                <div style="font-size: 10px; margin-bottom: 4px; color: #888;">SURVIVAL</div>
                <div class="bitmask-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px;">
                  <label class="bit-check" title="0"><input type="checkbox" id="gol-s0"><span>0</span></label>
                  <label class="bit-check" title="1"><input type="checkbox" id="gol-s1"><span>1</span></label>
                  <label class="bit-check" title="2"><input type="checkbox" id="gol-s2" checked><span>2</span></label>
                  <label class="bit-check" title="3"><input type="checkbox" id="gol-s3" checked><span>3</span></label>
                  <label class="bit-check" title="4"><input type="checkbox" id="gol-s4"><span>4</span></label>
                  <label class="bit-check" title="5"><input type="checkbox" id="gol-s5"><span>5</span></label>
                  <label class="bit-check" title="6"><input type="checkbox" id="gol-s6"><span>6</span></label>
                  <label class="bit-check" title="7"><input type="checkbox" id="gol-s7"><span>7</span></label>
                  <label class="bit-check" title="8"><input type="checkbox" id="gol-s8"><span>8</span></label>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 4. Lattice Control (Boundaries + Config) -->
      <div id="panel-lattice" class="panel">
        <div class="panel-header">
          <h3>Lattice Config</h3>
        </div>
        <div class="panel-body">
          <!-- Boundaries & Scroll -->
          <div>
            <div class="section-title">Boundaries & Displacement</div>
            <div class="section-content">
              <div class="boundary-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                <select id="bound-top" class="boundary-select" data-side="top">
                  <option value="periodic">Top: Periodic</option>
                  <option value="fixed">Top: Fixed</option>
                  <option value="reflect">Top: Reflect</option>
                  <option value="absorbing">Top: Absorbing</option>
                </select>
                <select id="bound-bottom" class="boundary-select" data-side="bottom">
                  <option value="periodic">Bot: Periodic</option>
                  <option value="fixed">Bot: Fixed</option>
                  <option value="reflect">Bot: Reflect</option>
                  <option value="absorbing">Bot: Absorbing</option>
                </select>
                <select id="bound-left" class="boundary-select" data-side="left">
                  <option value="periodic">Left: Periodic</option>
                  <option value="fixed">Left: Fixed</option>
                  <option value="reflect">Left: Reflect</option>
                  <option value="absorbing">Left: Absorbing</option>
                </select>
                <select id="bound-right" class="boundary-select" data-side="right">
                  <option value="periodic">Right: Periodic</option>
                  <option value="fixed">Right: Fixed</option>
                  <option value="reflect">Right: Reflect</option>
                  <option value="absorbing">Right: Absorbing</option>
                </select>
              </div>
              <div class="row space-between">
                <label style="font-size: 10px;">Fixed Value:</label>
                <select id="bound-fixed-val" style="width: 60px; height: 20px; padding: 0;">
                  <option value="1" selected>1</option>
                  <option value="-1">-1</option>
                </select>
              </div>

              <div style="border-top: 1px solid rgba(255,255,255,0.05); margin-top: 4px; padding-top: 4px;">
                <label style="font-size: 10px; color: #888;">Displacement (Vel)</label>
                <div class="row space-between" style="margin-top: 4px;">
                  <label>X</label>
                  <input type="range" id="scroll-vx" min="-1.0" max="1.0" step="0.1" value="0.0">
                  <input type="number" id="scroll-vx-num" step="0.1" value="0.0" style="width: 40px;">
                </div>
                <div class="row space-between" style="margin-top: 4px;">
                  <label>Y</label>
                  <input type="range" id="scroll-vy" min="-1.0" max="1.0" step="0.1" value="0.0">
                  <input type="number" id="scroll-vy-num" step="0.1" value="0.0" style="width: 40px;">
                </div>
              </div>
            </div>
          </div>

          <!-- General Config -->
          <div>
            <div class="section-title">Configuration</div>
            <div class="section-content">
              <div class="control-group">
                <label>Update Order</label>
                <div class="row" style="font-size: 11px;">
                  <input type="radio" name="order" id="order-async-sync" value="async_first" checked>
                  <label for="order-async-sync" style="font-size: 11px; margin-right: 8px;">Async → Sync</label>

                  <input type="radio" name="order" id="order-sync-async" value="sync_first">
                  <label for="order-sync-async" style="font-size: 11px;">Sync → Async</label>
                </div>
              </div>

              <div class="control-group">
                <div class="row space-between">
                  <label>Density: </label>
                  <select id="density-select">
                    <option value="20">Coarse (20px)</option>
                    <option value="10">Normal (10px)</option>
                    <option value="5" selected>Fine (5px)</option>
                    <option value="2">Ultra (2px)</option>
                  </select>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 5. History / 3D Control -->
      <div id="panel-history" class="panel">
        <div class="panel-header">
          <h3>History / SpaceTime</h3>
        </div>
        <div class="panel-body">
          <div class="control-group">
            <div class="row space-between">
              <label>Buffer Cap</label>
              <span style="font-size: 11px; color:#fff">200 frames</span>
            </div>
            <div class="row space-between">
              <label>Stored</label>
              <span id="hist-count" style="font-size: 11px; color:#fff">0</span>
            </div>
          </div>

          <div class="control-group" style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px;">
            <label>Selection</label>
            <div id="sel-info" style="font-size: 10px; color: #888; min-height: 1.2em;">Click a blob to select</div>

            <div class="row space-between" style="margin-top: 8px;">
              <label style="font-size: 10px;">Track Duration</label>
              <span id="track-frames-val" style="font-size: 10px; color:#fff">200</span>
            </div>
            <input type="range" id="track-frames" min="10" max="200" step="10" value="200">

            <div class="row space-between" style="margin-top: 8px;">
              <label style="font-size: 10px;">Max Voxels</label>
              <span id="max-voxels-val" style="font-size: 10px; color:#fff">20k</span>
            </div>
            <input type="range" id="max-voxels" min="1000" max="100000" step="1000" value="20000">

            <button id="btn-track" disabled style="margin-top: 8px;">Track Structure (3D)</button>
          </div>
        </div>
      </div>

    </div> <!-- End sidebar-content -->
  </div> <!-- End sidebar-container -->

  <!-- 3D Viewer Overlay (Hidden by default) -->
  <div id="viewer-3d"
    style="display: none; position: absolute; inset: 40px; background: #111; z-index: 1000; border: 1px solid #333; border-radius: 8px; box-shadow: 0 0 50px rgba(0,0,0,0.8); flex-direction: column;">
    <div
      style="padding: 10px; background: #222; border-bottom: 1px solid #333; display: flex; justify-content: space-between;">
      <h3 style="margin: 0; font-size: 14px; color: #eee;">SpaceTime Visualization</h3>
      <button id="close-viewer" style="background: transparent; color: #fff; width: auto; flex: 0;">✕</button>
    </div>
    <div id="container-3d" style="flex: 1; position: relative;"></div>
    <div style="padding: 10px; background: #222; border-top: 1px solid #333; display: flex; gap: 8px;">
      <button id="export-glb">Export GLB</button>
    </div>
  </div>


  <script type="module">
    import { RollingBuffer, traceBackward, traceForward, renderSpacetimeStructure, exportToGLB, getConnectedComponent } from './history.js';
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Global App State
    const App = {
      sim: null,
      mem: null,
      buffer: null,
      playing: true,
      width: 100, // Initial estimate
      height: 100,
      height: 100,
      cellSize: 5, // Default Fine
      lastTime: 0,
      lastTime: 0,
      fpsInterval: 1000 / 60,
      animationId: null,
      selectedBlob: null
    };

    // Canvas
    const canvas = document.getElementById('game-of-life-canvas');
    const ctx = canvas.getContext('2d');

    // Wait for Wasm Bridge
    // Wait for Wasm Bridge (Handle Race Condition)
    if (window.simulationInstance) {
      console.log("Wasm already loaded");
      App.sim = window.simulationInstance;
      App.mem = window.wasmMemory;
      initApp();
    } else {
      window.addEventListener('wasm-ready', () => {
        console.log("Wasm Ready Detected");
        App.sim = window.simulationInstance;
        App.mem = window.wasmMemory;
        initApp();
      });
    }

    function initApp() {
      console.log("Initializing App...");

      // Initial Window Setup
      handleResize();

      // Setup Buffer
      // Note: Buffer needs to resize if simulation resizes. 
      // We'll init buffer with initial size.
      App.width = App.sim.get_width();
      App.height = App.sim.get_height();
      App.buffer = new RollingBuffer(200, App.width, App.height);

      // Bind UI Controls
      bindControls();

      // Start Loop
      App.lastTime = performance.now();
      loop();
    }

    function loop(timestamp) {
      App.animationId = requestAnimationFrame(loop);

      const now = timestamp || performance.now();
      const elapsed = now - App.lastTime;

      if (elapsed > App.fpsInterval) {
        App.lastTime = now - (elapsed % App.fpsInterval);

        if (App.playing) {
          App.sim.tick();
          // Push to buffer
          App.buffer.push(App.sim.get_cells_ptr(), App.mem);
          // Update stats
          updateMeasurements();
          updateHistoryStats();
        }

        draw();
      }
    }

    function draw() {
      // Clear
      ctx.fillStyle = "#050505";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (!App.sim) return;

      const width = App.sim.get_width();
      const height = App.sim.get_height();
      const size = App.cellSize;

      const ptr = App.sim.get_cells_ptr();
      const cells = new Int32Array(App.mem.buffer, ptr, width * height);

      ctx.beginPath();
      // Since we are iterating potentially many cells, optimizing drawing is good.
      // But the previous implementation just drew one by one.
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          const val = cells[idx];

          if (val === 1) {
            ctx.fillStyle = "#FFFFFF";
            ctx.fillRect(x * size, y * size, size, size);
          } else if (App.selectedBlob && App.selectedBlob.has(idx)) {
            // Highlight selected blob ghost if dead? 
            // Or if val === 1 logic handles it.
            // If we want to highlight the selected blob separately:
            ctx.fillStyle = "#FF0000"; // Red highlight
            ctx.fillRect(x * size, y * size, size, size);
          }
        }
      }

      // Highlight selection overlay
      if (App.selectedBlob) {
        ctx.fillStyle = "rgba(0, 255, 0, 0.3)";
        for (const idx of App.selectedBlob) {
          const x = idx % width;
          const y = Math.floor(idx / width);
          ctx.fillRect(x * size, y * size, size, size);
        }
      }
    }

    // --- UI Bindings ---

    // --- UI Bindings ---

    function bindControls() {
      // --- Playback ---
      document.getElementById('play-pause').addEventListener('click', () => {
        App.playing = !App.playing;
        document.getElementById('play-pause').textContent = App.playing ? "Pause" : "Play";
      });

      document.getElementById('step-btn').addEventListener('click', () => {
        App.playing = false;
        document.getElementById('play-pause').textContent = "Play";
        App.sim.tick();
        App.buffer.push(App.sim.get_cells_ptr(), App.mem);
        draw();
        updateMeasurements();
      });

      document.getElementById('reset-btn').addEventListener('click', () => {
        App.sim.reset();
        draw();
      });

      document.getElementById('speed-slider').addEventListener('input', (e) => {
        const fps = parseInt(e.target.value);
        App.fpsInterval = 1000 / fps;
      });

      // --- Config / Update Order ---
      const updateConfig = () => {
        const sync = document.getElementById('sync-enabled').checked;
        const asyncRun = document.getElementById('async-enabled').checked;
        const order = document.querySelector('input[name="order"]:checked').value;
        const rate = parseFloat(document.getElementById('async-rate').value);
        App.sim.set_update_config(sync, asyncRun, order, rate);
      };

      document.getElementById('sync-enabled').addEventListener('change', updateConfig);
      document.getElementById('async-enabled').addEventListener('change', updateConfig);
      document.querySelectorAll('input[name="order"]').forEach(el => el.addEventListener('change', updateConfig));
      // async rate listeners
      const bindSync = (id1, id2, callback) => {
        const el1 = document.getElementById(id1);
        const el2 = document.getElementById(id2);
        el1.addEventListener('input', () => { el2.value = el1.value; callback(); });
        el2.addEventListener('input', () => { el1.value = el2.value; callback(); });
      };
      bindSync('async-rate', 'async-rate-num', updateConfig);

      // --- Ising Params ---
      const updateIsing = () => {
        const temp = parseFloat(document.getElementById('ising-temp').value);
        const h = parseFloat(document.getElementById('ising-h').value);
        const j = parseFloat(document.getElementById('ising-j').value);
        App.sim.set_ising_params(temp, h, j, "metropolis");
      };
      bindSync('ising-temp', 'ising-temp-range', updateIsing);
      bindSync('ising-h', 'ising-h-range', updateIsing);
      bindSync('ising-j', 'ising-j-range', updateIsing);

      // --- GoL Rules ---
      const updateGoL = () => {
        let birth = 0;
        let survival = 0;
        for (let i = 0; i <= 8; i++) {
          if (document.getElementById(`gol-b${i}`).checked) birth |= (1 << i);
          if (document.getElementById(`gol-s${i}`).checked) survival |= (1 << i);
        }
        App.sim.set_gol_rules(birth, survival);
      };
      for (let i = 0; i <= 8; i++) {
        document.getElementById(`gol-b${i}`).addEventListener('change', updateGoL);
        document.getElementById(`gol-s${i}`).addEventListener('change', updateGoL);
      }

      // --- Lattice / Scroll ---
      const updateBoundaries = () => {
        const mapVal = (val) => {
          if (val === 'fixed') return 1;
          if (val === 'reflect') return 2;
          if (val === 'absorbing') return 3;
          return 0; // periodic
        };
        const top = mapVal(document.getElementById('bound-top').value);
        const bottom = mapVal(document.getElementById('bound-bottom').value);
        const left = mapVal(document.getElementById('bound-left').value);
        const right = mapVal(document.getElementById('bound-right').value);
        const fixedVal = parseInt(document.getElementById('bound-fixed-val').value);

        App.sim.set_boundaries(top, bottom, left, right, fixedVal);
      };

      ['bound-top', 'bound-bottom', 'bound-left', 'bound-right', 'bound-fixed-val'].forEach(id => {
        document.getElementById(id).addEventListener('change', updateBoundaries);
      });

      const updateScroll = () => {
        const vx = parseFloat(document.getElementById('scroll-vx').value);
        const vy = parseFloat(document.getElementById('scroll-vy').value);
        App.sim.set_scroll_velocity(vx, vy);
      };
      bindSync('scroll-vx', 'scroll-vx-num', updateScroll);
      bindSync('scroll-vy', 'scroll-vy-num', updateScroll);

      // --- App / Display ---
      document.getElementById('density-select').addEventListener('change', (e) => {
        App.cellSize = parseInt(e.target.value);
        handleResize();
      });

      window.addEventListener('resize', handleResize);

      canvas.addEventListener('mousedown', handleCanvasClick);

      document.getElementById('btn-track').addEventListener('click', () => {
        if (App.selectedBlob) {
          runTracking();
        }
      });

      document.getElementById('export-glb').addEventListener('click', () => {
        if (window.lastScene) {
          exportToGLB(window.lastScene);
        }
      });

      // Tracking Frames Slider
      const trackSlider = document.getElementById('track-frames');
      const trackVal = document.getElementById('track-frames-val');
      trackSlider.addEventListener('input', () => {
        trackVal.textContent = trackSlider.value;
      });

      // Max Voxels Slider
      const voxelSlider = document.getElementById('max-voxels');
      const voxelVal = document.getElementById('max-voxels-val');
      voxelSlider.addEventListener('input', () => {
        let v = parseInt(voxelSlider.value);
        if (v >= 1000) {
          voxelVal.textContent = (v / 1000) + 'k';
        } else {
          voxelVal.textContent = v;
        }
      });

      document.getElementById('close-viewer').addEventListener('click', () => {
        document.getElementById('viewer-3d').style.display = 'none';
      });

      // Initial setup calls
      updateConfig();
      updateIsing();
      updateGoL();
      updateBoundaries();
      updateScroll();
    }

    function handleResize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      canvas.width = w;
      canvas.height = h;

      App.width = Math.floor(w / App.cellSize);
      App.height = Math.floor(h / App.cellSize);

      if (App.sim) {
        App.sim.set_resolution(App.width, App.height);
        // Re-init buffer because dimensions changed
        App.buffer = new RollingBuffer(200, App.width, App.height);
      }
      draw();
    }

    function updateMeasurements() {
      // We can call get_measurements from Rust
      // Sim has get_measurements() -> Vec<f64>
      // But returning Vec<f64> to JS results in Float64Array
      const m = App.sim.get_measurements();
      document.getElementById('meas-density').textContent = m[0].toFixed(3);
      document.getElementById('meas-mag').textContent = m[1].toFixed(3);
      document.getElementById('meas-energy').textContent = m[2].toFixed(2);
    }

    function updateHistoryStats() {
      if (App.buffer) {
        document.getElementById('hist-count').textContent = App.buffer.count;
      }
    }

    function handleCanvasClick(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      const x = Math.floor(mx / App.cellSize);
      const y = Math.floor(my / App.cellSize);

      const idx = y * App.width + x;

      // Get current frame
      const ptr = App.sim.get_cells_ptr();
      const cells = new Int32Array(App.mem.buffer, ptr, App.width * App.height);

      // Flood fill to find component
      const component = getConnectedComponent(cells, idx, App.width, App.height);

      if (component.size > 0) {
        App.selectedBlob = component;
        document.getElementById('sel-info').textContent = `Selected size: ${component.size}`;
        document.getElementById('btn-track').disabled = false;
        draw();
      } else {
        App.selectedBlob = null;
        document.getElementById('sel-info').textContent = "No blob selected";
        document.getElementById('btn-track').disabled = true;
        draw();
      }
    }

    function runTracking() {
      App.playing = false; // Pause

      const maxFrames = parseInt(document.getElementById('track-frames').value);
      const maxVoxels = parseInt(document.getElementById('max-voxels').value);

      // 1. Trace Backward
      const back = traceBackward(App.buffer, App.selectedBlob, App.width, App.height, maxFrames);

      // 2. Trace Forward
      const fwd = traceForward(App.sim, App.selectedBlob, maxFrames); // Use visual slider val

      // 3. Render
      const scene = renderSpacetimeStructure(back, fwd, App.width, App.height, maxVoxels);
      window.lastScene = scene; // Store for export

      // Show Viewer
      const viewer = document.getElementById('viewer-3d');
      viewer.style.display = 'flex';

      init3D(scene);
    }

    function init3D(structureGroup) {
      const container = document.getElementById('container-3d');
      const viewer = document.getElementById('viewer-3d');
      container.innerHTML = ''; // Clear previous

      const w = container.clientWidth;
      const h = container.clientHeight;

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x222222);

      const camera = new THREE.PerspectiveCamera(75, w / h, 0.1, 1000);
      camera.position.set(0, 0, 100);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(w, h);
      container.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);

      // Lighting
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(1, 1, 1).normalize();
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x404040));

      // Add structure
      scene.add(structureGroup);

      // Resize handler for 3D
      const resizeObserver = new ResizeObserver(() => {
        const wn = container.clientWidth;
        const hn = container.clientHeight;
        renderer.setSize(wn, hn);
        camera.aspect = wn / hn;
        camera.updateProjectionMatrix();
      });
      resizeObserver.observe(container);

      function animate() {
        if (viewer.style.display === 'none') return;
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
    }

    // --- Sidebar & Drag Reorder Logic ---
    function initSidebar() {
      const toggleBtn = document.getElementById('sidebar-toggle');
      const sidebar = document.getElementById('sidebar-container');
      const container = document.getElementById('sidebar-content');

      // Toggle Sidebar
      toggleBtn.addEventListener('click', () => {
        sidebar.classList.toggle('collapsed');
      });

    }

    // --- Global Keys ---
    function initInputs() {
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          App.playing = !App.playing;
          document.getElementById('play-pause').textContent = App.playing ? "Pause" : "Play";
        }
      });
    }

    // Run UI Init
    initSidebar();
    initInputs();
  </script>
<script>"use strict";

(function () {

    const address = '{{__TRUNK_ADDRESS__}}';
    const base = '{{__TRUNK_WS_BASE__}}';
    let protocol = '';
    protocol =
        protocol
            ? protocol
            : window.location.protocol === 'https:'
                ? 'wss'
                : 'ws';
    const url = protocol + '://' + address + base + '.well-known/trunk/ws';

    class Overlay {
        constructor() {
            // create an overlay
            this._overlay = document.createElement("div");
            const style = this._overlay.style;
            style.height = "100vh";
            style.width = "100vw";
            style.position = "fixed";
            style.top = "0";
            style.left = "0";
            style.backgroundColor = "rgba(222, 222, 222, 0.5)";
            style.fontFamily = "sans-serif";
            // not sure that's the right approach
            style.zIndex = "1000000";
            style.backdropFilter = "blur(1rem)";

            const container = document.createElement("div");
            // center it
            container.style.position = "absolute";
            container.style.top = "30%";
            container.style.left = "15%";
            container.style.maxWidth = "85%";

            this._title = document.createElement("div");
            this._title.innerText = "Build failure";
            this._title.style.paddingBottom = "2rem";
            this._title.style.fontSize = "2.5rem";

            this._message = document.createElement("div");
            this._message.style.whiteSpace = "pre-wrap";

            const icon= document.createElement("div");
            icon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="#dc3545" viewBox="0 0 16 16"><path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/></svg>';
            this._title.prepend(icon);

            container.append(this._title, this._message);
            this._overlay.append(container);

            this._inject();
            window.setInterval(() => {
                this._inject();
            }, 250);
        }

        set reason(reason) {
            this._message.textContent = reason;
        }

        _inject() {
            if (!this._overlay.isConnected) {
                // prepend it
                document.body?.prepend(this._overlay);
            }
        }

    }

    class Client {
        constructor(url) {
            this.url = url;
            this.poll_interval = 5000;
            this._overlay = null;
        }

        start() {
            const ws = new WebSocket(this.url);
            ws.onmessage = (ev) => {
                const msg = JSON.parse(ev.data);
                switch (msg.type) {
                    case "reload":
                        this.reload();
                        break;
                    case "buildFailure":
                        this.buildFailure(msg.data)
                        break;
                }
            };
            ws.onclose = () => this.onclose();
        }

        onclose() {
            window.setTimeout(
                () => {
                    // when we successfully reconnect, we'll force a
                    // reload (since we presumably lost connection to
                    // trunk due to it being killed, so it will have
                    // rebuilt on restart)
                    const ws = new WebSocket(this.url);
                    ws.onopen = () => window.location.reload();
                    ws.onclose = () => this.onclose();
                },
                this.poll_interval);
        }

        reload() {
            window.location.reload();
        }

        buildFailure({reason}) {
            // also log the console
            console.error("Build failed:", reason);

            console.debug("Overlay", this._overlay);

            if (!this._overlay) {
                this._overlay = new Overlay();
            }
            this._overlay.reason = reason;
        }
    }

    new Client(url).start();

})()
</script></body>

</html>