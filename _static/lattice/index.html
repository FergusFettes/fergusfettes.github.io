<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Lattice Simulator</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  
<script type="module">
import init, * as bindings from './lattice-gol-f3861f87b0f78826.js';
const wasm = await init({ module_or_path: './lattice-gol-f3861f87b0f78826_bg.wasm' });


window.wasmBindings = bindings;


dispatchEvent(new CustomEvent("TrunkApplicationStarted", {detail: {wasm}}));

</script>
  
  
  <style>
    body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #050505;
      font-family: 'Inter', sans-serif;
      color: #eee;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #sidebar-container {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      width: 320px;
      display: flex;
      flex-direction: column;
      z-index: 20;
      transition: transform 0.3s ease;
      background: rgba(30, 30, 30, 0.85);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }

    #sidebar-container.collapsed {
      transform: translateX(320px);
    }

    #sidebar-header {
      height: 48px;
      display: flex;
      align-items: center;
      padding: 0 16px;
      background: rgba(255, 255, 255, 0.05);
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    #sidebar-title {
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.5px;
      color: #eee;
    }

    #sidebar-toggle {
      position: absolute;
      left: -32px;
      top: 12px;
      width: 32px;
      height: 32px;
      background: rgba(30, 30, 30, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-right: none;
      border-radius: 6px 0 0 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #ccc;
      font-size: 16px;
    }

    #sidebar-toggle:hover {
      color: #fff;
      background: rgba(50, 50, 50, 0.9);
    }

    #sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 0;
    }

    #sidebar-content::-webkit-scrollbar {
      width: 6px;
    }

    #sidebar-content::-webkit-scrollbar-track {
      background: transparent;
    }

    #sidebar-content::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 3px;
    }

    .panel {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 8px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .panel-header {
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.03);
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
    }

    .panel-header h3 {
      margin: 0;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.5px;
      opacity: 0.9;
    }

    .panel-controls {
      display: flex;
      gap: 4px;
    }

    .header-btn {
      background: transparent;
      border: none;
      color: #888;
      cursor: pointer;
      padding: 2px;
      font-size: 14px;
      border-radius: 4px;
    }

    .header-btn:hover {
      color: #fff;
      background: rgba(255, 255, 255, 0.1);
    }

    .panel-body {
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .section-title {
      font-size: 11px;
      font-weight: 600;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
      padding-bottom: 4px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    label {
      font-size: 12px;
      color: #aaa;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .space-between {
      justify-content: space-between;
    }

    select,
    input[type="number"],
    input[type="range"] {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #fff;
      padding: 6px 10px;
      border-radius: 6px;
      font-family: inherit;
      font-size: 13px;
      outline: none;
    }

    select {
      width: 100%;
      cursor: pointer;
    }

    input[type="number"] {
      width: 60px;
    }

    input[type="range"] {
      flex: 1;
      cursor: pointer;
    }

    button {
      background: #3a86ff;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: background 0.2s;
      flex: 1;
    }

    button:hover {
      background: #2671eb;
    }

    button.secondary {
      background: rgba(255, 255, 255, 0.1);
    }

    button.secondary:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .bit-check {
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
      cursor: pointer;
      padding: 2px;
      user-select: none;
    }

    .bit-check input {
      display: none;
    }

    .bit-check span {
      font-size: 10px;
      color: #666;
      font-weight: bold;
    }

    .bit-check input:checked+span {
      color: #fff;
    }

    .bit-check:has(input:checked) {
      background: #3a86ff;
    }


    .section-content {
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .config-btn-row {
      display: flex;
      gap: 4px;
    }

    .config-btn-row button {
      font-size: 11px;
      padding: 6px 8px;
    }

    .toast {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%) translateY(80px);
      background: rgba(58, 134, 255, 0.95);
      color: #fff;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      pointer-events: none;
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 9999;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
  </style>
<link rel="modulepreload" href="./lattice-gol-f3861f87b0f78826.js" crossorigin="anonymous" integrity="sha384-23lnOOd6PkuvoV0JY6ASzbk/lc380Y80Vx6lXit1BcJPMEw5WbqpanYIn/j7Qcmp"><link rel="preload" href="./lattice-gol-f3861f87b0f78826_bg.wasm" crossorigin="anonymous" integrity="sha384-b1ioa6aDYAoNfJBTKSFVPxtmVLSR9NwppeZmRuD8LPmKfP0W1Tr8wYU21sY1qeP6" as="fetch" type="application/wasm"></head>

<body>
  <canvas id="game-of-life-canvas"></canvas>

  <!-- Sidebar -->
  <div id="sidebar-container">
    <button id="sidebar-toggle">☰</button>
    <div id="sidebar-header">
      <span id="sidebar-title">Controls</span>
    </div>
    <div id="sidebar-content">

      <!-- 1. Main Control -->
      <div id="panel-main" class="panel">
        <div class="panel-header">
          <h3>Main Control</h3>
        </div>
        <div class="panel-body">
          <div class="section-title">Measurements</div>
          <div id="measurements-grid"
            style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px; color: #888;">
            <div>Dens: <span id="meas-density" style="color:#eee">0.00</span></div>
            <div>Mag: <span id="meas-mag" style="color:#eee">0.00</span></div>
            <div>Energy: <span id="meas-energy" style="color:#eee">0.00</span></div>
            <div>FPS: <span id="meas-fps" style="color:#eee">60</span></div>
          </div>
          <div class="control-group">
            <div class="row space-between">
              <label>Speed</label>
              <input type="range" id="speed-slider" min="1" max="60" value="60">
            </div>
          </div>
          <div class="row" style="margin-top: 4px; padding: 0 4px;">
            <button id="play-pause">Pause</button>
            <button id="step-btn" class="secondary">Step</button>
            <button id="reset-btn" class="secondary">Reset</button>
          </div>
        </div>
      </div>

      <!-- 2. Ising Control -->
      <div id="panel-ising" class="panel">
        <div class="panel-header">
          <h3>Ising Model</h3>
        </div>
        <div class="panel-body">
          <div class="row">
            <input type="checkbox" id="async-enabled" checked>
            <label for="async-enabled" style="color: #fff;">Enable Async Update</label>
          </div>
          <div id="async-controls">
            <div class="row space-between">
              <label>Temp (T)</label>
              <input type="number" id="ising-temp" step="0.1" value="2.27" style="width: 50px;">
            </div>
            <input type="range" id="ising-temp-range" min="0.1" max="5.0" step="0.01" value="2.27">

            <div class="row space-between" style="margin-top: 4px;">
              <label>Field (h)</label>
              <input type="number" id="ising-h" step="0.1" value="0.0" style="width: 50px;">
            </div>
            <input type="range" id="ising-h-range" min="-2.0" max="2.0" step="0.01" value="0.0">

            <div class="row space-between" style="margin-top: 4px;">
              <label>Coupling (J)</label>
              <input type="number" id="ising-j" step="0.1" value="1.0" style="width: 50px;">
            </div>
            <input type="range" id="ising-j-range" min="-2.0" max="2.0" step="0.01" value="1.0">

            <div class="row space-between" style="margin-top: 8px;">
              <label>Sweeps/Frame</label>
              <input type="number" id="async-rate-num" step="0.1" value="1.0" style="width: 50px;">
            </div>
            <input type="range" id="async-rate" min="0.0" max="2.0" step="0.01" value="1.0">
          </div>
        </div>
      </div>

      <!-- 3. GoL Control -->
      <div id="panel-gol" class="panel">
        <div class="panel-header">
          <h3>Game of Life</h3>
        </div>
        <div class="panel-body">
          <div class="row">
            <input type="checkbox" id="sync-enabled">
            <label for="sync-enabled" style="color: #fff;">Enable Sync Update</label>
          </div>
          <div id="sync-controls">
            <div style="display: flex; gap: 12px;">
              <div style="flex: 1;">
                <div style="font-size: 10px; margin-bottom: 4px; color: #888;">BIRTH</div>
                <div class="bitmask-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px;">
                  <label class="bit-check" title="0"><input type="checkbox" id="gol-b0"><span>0</span></label>
                  <label class="bit-check" title="1"><input type="checkbox" id="gol-b1"><span>1</span></label>
                  <label class="bit-check" title="2"><input type="checkbox" id="gol-b2"><span>2</span></label>
                  <label class="bit-check" title="3"><input type="checkbox" id="gol-b3" checked><span>3</span></label>
                  <label class="bit-check" title="4"><input type="checkbox" id="gol-b4"><span>4</span></label>
                  <label class="bit-check" title="5"><input type="checkbox" id="gol-b5"><span>5</span></label>
                  <label class="bit-check" title="6"><input type="checkbox" id="gol-b6"><span>6</span></label>
                  <label class="bit-check" title="7"><input type="checkbox" id="gol-b7"><span>7</span></label>
                  <label class="bit-check" title="8"><input type="checkbox" id="gol-b8"><span>8</span></label>
                </div>
              </div>
              <div style="flex: 1;">
                <div style="font-size: 10px; margin-bottom: 4px; color: #888;">SURVIVAL</div>
                <div class="bitmask-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px;">
                  <label class="bit-check" title="0"><input type="checkbox" id="gol-s0"><span>0</span></label>
                  <label class="bit-check" title="1"><input type="checkbox" id="gol-s1"><span>1</span></label>
                  <label class="bit-check" title="2"><input type="checkbox" id="gol-s2" checked><span>2</span></label>
                  <label class="bit-check" title="3"><input type="checkbox" id="gol-s3" checked><span>3</span></label>
                  <label class="bit-check" title="4"><input type="checkbox" id="gol-s4"><span>4</span></label>
                  <label class="bit-check" title="5"><input type="checkbox" id="gol-s5"><span>5</span></label>
                  <label class="bit-check" title="6"><input type="checkbox" id="gol-s6"><span>6</span></label>
                  <label class="bit-check" title="7"><input type="checkbox" id="gol-s7"><span>7</span></label>
                  <label class="bit-check" title="8"><input type="checkbox" id="gol-s8"><span>8</span></label>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 4. Lattice Config -->
      <div id="panel-lattice" class="panel">
        <div class="panel-header">
          <h3>Lattice Config</h3>
        </div>
        <div class="panel-body">
          <div class="section-title">Boundaries & Displacement</div>
          <div class="boundary-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
            <select id="bound-top" class="boundary-select" data-side="top">
              <option value="periodic">Top: Periodic</option>
              <option value="fixed">Top: Fixed</option>
              <option value="reflect">Top: Reflect</option>
              <option value="absorbing">Top: Absorbing</option>
            </select>
            <select id="bound-bottom" class="boundary-select" data-side="bottom">
              <option value="periodic">Bot: Periodic</option>
              <option value="fixed">Bot: Fixed</option>
              <option value="reflect">Bot: Reflect</option>
              <option value="absorbing">Bot: Absorbing</option>
            </select>
            <select id="bound-left" class="boundary-select" data-side="left">
              <option value="periodic">Left: Periodic</option>
              <option value="fixed">Left: Fixed</option>
              <option value="reflect">Left: Reflect</option>
              <option value="absorbing">Left: Absorbing</option>
            </select>
            <select id="bound-right" class="boundary-select" data-side="right">
              <option value="periodic">Right: Periodic</option>
              <option value="fixed">Right: Fixed</option>
              <option value="reflect">Right: Reflect</option>
              <option value="absorbing">Right: Absorbing</option>
            </select>
          </div>
          <div class="row space-between">
            <label style="font-size: 10px;">Fixed Value:</label>
            <select id="bound-fixed-val" style="width: 60px; height: 20px; padding: 0;">
              <option value="1" selected>1</option>
              <option value="-1">-1</option>
            </select>
          </div>

          <div style="border-top: 1px solid rgba(255,255,255,0.05); margin-top: 4px; padding-top: 4px;">
            <label style="font-size: 10px; color: #888;">Displacement (Vel)</label>
            <div class="row space-between" style="margin-top: 4px;">
              <label>X</label>
              <input type="range" id="scroll-vx" min="-1.0" max="1.0" step="0.1" value="0.0">
              <input type="number" id="scroll-vx-num" step="0.1" value="0.0" style="width: 40px;">
            </div>
            <div class="row space-between" style="margin-top: 4px;">
              <label>Y</label>
              <input type="range" id="scroll-vy" min="-1.0" max="1.0" step="0.1" value="0.0">
              <input type="number" id="scroll-vy-num" step="0.1" value="0.0" style="width: 40px;">
            </div>
          </div>

          <div class="section-title">Configuration</div>
          <div class="control-group">
            <label>Update Order</label>
            <div class="row" style="font-size: 11px;">
              <input type="radio" name="order" id="order-async-sync" value="async_first" checked>
              <label for="order-async-sync" style="font-size: 11px; margin-right: 8px;">Async → Sync</label>

              <input type="radio" name="order" id="order-sync-async" value="sync_first">
              <label for="order-sync-async" style="font-size: 11px;">Sync → Async</label>
            </div>
          </div>

          <div class="control-group">
            <div class="row space-between">
              <label>Density: </label>
              <select id="density-select">
                <option value="10">Coarse (10px)</option>
                <option value="5">Normal (5px)</option>
                <option value="3" selected>Fine (3px)</option>
                <option value="2">Dense (2px)</option>
                <option value="1">Ultra (1px)</option>
              </select>
            </div>
          </div>

          <div class="section-title">Presets</div>
          <div class="config-btn-row">
            <button id="btn-dump-config" class="secondary">Save JSON</button>
            <button id="btn-load-config" class="secondary">Load JSON</button>
            <button id="btn-copy-config" class="secondary">Copy</button>
            <button id="btn-copy-link" class="secondary">Link</button>
          </div>
          <input type="file" id="config-file-input" accept=".json" style="display:none;">
        </div>
      </div>

      <!-- 5. History / SpaceTime -->
      <div id="panel-history" class="panel">
        <div class="panel-header">
          <h3>History / SpaceTime</h3>
        </div>
        <div class="panel-body">
          <div class="control-group">
            <div class="row space-between">
              <label>Buffer Cap</label>
              <span style="font-size: 11px; color:#fff">200 frames</span>
            </div>
            <div class="row space-between">
              <label>Stored</label>
              <span id="hist-count" style="font-size: 11px; color:#fff">0</span>
            </div>
          </div>

          <div class="control-group" style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px;">
            <label>Selection</label>
            <div id="sel-info" style="font-size: 10px; color: #888; min-height: 1.2em;">Click a blob to select</div>

            <div class="row space-between" style="margin-top: 8px;">
              <label style="font-size: 10px;">Track Duration</label>
              <span id="track-frames-val" style="font-size: 10px; color:#fff">200</span>
            </div>
            <input type="range" id="track-frames" min="10" max="200" step="10" value="200">

            <div class="row space-between" style="margin-top: 8px;">
              <label style="font-size: 10px;">Max Voxels</label>
              <span id="max-voxels-val" style="font-size: 10px; color:#fff">20k</span>
            </div>
            <input type="range" id="max-voxels" min="1000" max="50000" step="1000" value="20000">

            <button id="btn-track" disabled style="margin-top: 8px;">Track Structure (3D)</button>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- 3D Viewer Overlay (Hidden by default) -->
  <div id="viewer-3d"
    style="display: none; position: absolute; inset: 40px; background: #111; z-index: 1000; border: 1px solid #333; border-radius: 8px; box-shadow: 0 0 50px rgba(0,0,0,0.8); flex-direction: column;">
    <div
      style="padding: 10px; background: #222; border-bottom: 1px solid #333; display: flex; justify-content: space-between;">
      <h3 style="margin: 0; font-size: 14px; color: #eee;">SpaceTime Visualization</h3>
      <button id="close-viewer" style="background: transparent; color: #fff; width: auto; flex: 0;">✕</button>
    </div>
    <div id="container-3d" style="flex: 1; position: relative;"></div>
    <div style="padding: 10px; background: #222; border-top: 1px solid #333; display: flex; gap: 8px;">
      <button id="export-glb">Export GLB</button>
    </div>
  </div>


  <div id="toast" class="toast"></div>

  <script type="module">
    import { RollingBuffer, traceBackward, traceForward, renderSpacetimeStructure, exportToGLB, getConnectedComponent } from './history.js';
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Global App State
    const App = {
      sim: null,
      mem: null,
      buffer: null,
      playing: true,
      width: 100, // Initial estimate
      height: 100,
      height: 100,
      cellSize: 3, // Default Fine
      lastTime: 0,
      lastTime: 0,
      fpsInterval: 1000 / 60,
      animationId: null,
      selectedBlob: null,
      canvasBuffer: null,
      canvasContext: null,
      imgData: null,
      fpsLastTime: 0,
      fpsFrameCount: 0
    };

    // Canvas
    const canvas = document.getElementById('game-of-life-canvas');
    const ctx = canvas.getContext('2d');

    // Wait for Wasm Bridge
    // Wait for Wasm Bridge (Handle Race Condition)
    if (window.simulationInstance) {
      console.log("Wasm already loaded");
      App.sim = window.simulationInstance;
      App.mem = window.wasmMemory;
      initApp();
    } else {
      window.addEventListener('wasm-ready', () => {
        console.log("Wasm Ready Detected");
        App.sim = window.simulationInstance;
        App.mem = window.wasmMemory;
        initApp();
      });
    }

    function initApp() {
      console.log("Initializing App...");

      // Setup Buffer
      // Note: Buffer needs to resize if simulation resizes. 
      // We'll init buffer with initial size.
      App.width = App.sim.get_width();
      App.height = App.sim.get_height();
      App.buffer = new RollingBuffer(200, App.width, App.height);

      // Offscreen canvas for pixel blitting
      const offscreen = document.createElement('canvas');
      offscreen.width = App.width;
      offscreen.height = App.height;
      App.canvasBuffer = offscreen;
      App.canvasContext = offscreen.getContext('2d', { alpha: false });
      App.imgData = App.canvasContext.createImageData(App.width, App.height);
      ctx.imageSmoothingEnabled = false;

      // Initial Window Setup
      handleResize();

      // Bind UI Controls
      bindControls();

      // Start Loop
      App.lastTime = performance.now();
      loop();

      // Load config from URL hash if present (e.g. #config=<base64>)
      loadConfigFromURL();
    }

    function loop(timestamp) {
      App.animationId = requestAnimationFrame(loop);

      const now = timestamp || performance.now();
      const elapsed = now - App.lastTime;

      App.fpsFrameCount++;
      if (now - App.fpsLastTime >= 500) {
        const fps = Math.round((App.fpsFrameCount * 1000) / (now - App.fpsLastTime));
        document.getElementById('meas-fps').textContent = fps;
        App.fpsFrameCount = 0;
        App.fpsLastTime = now;
      }

      if (elapsed > App.fpsInterval) {
        App.lastTime = now - (elapsed % App.fpsInterval);

        if (App.playing) {
          App.sim.tick();
          // Push to buffer
          App.buffer.push(App.sim.get_cells_ptr(), App.mem);
          // Update stats
          updateMeasurements();
          updateHistoryStats();
        }

        draw();
      }
    }

    function draw() {
      if (!App.sim) return;
      const width = App.sim.get_width();
      const height = App.sim.get_height();
      const ptr = App.sim.get_cells_ptr();
      const cells = new Int32Array(App.mem.buffer, ptr, width * height);
      const data = App.imgData.data;
      const buf32 = new Uint32Array(data.buffer);
      const C_BG = 0xFF050505;
      const C_FG = 0xFFFFFFFF;
      const C_SEL = 0xFF0000FF;
      const C_OVERLAY = 0x4D00FF00;
      for (let i = 0; i < width * height; i++) {
        const val = cells[i];
        if (val === 1) {
          buf32[i] = C_FG;
        } else if (App.selectedBlob && App.selectedBlob.has(i)) {
          buf32[i] = C_SEL;
        } else {
          buf32[i] = C_BG;
        }
      }
      App.canvasContext.putImageData(App.imgData, 0, 0);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(App.canvasBuffer, 0, 0, canvas.width, canvas.height);
      if (App.selectedBlob) {
        ctx.fillStyle = "rgba(0, 255, 0, 0.3)";
        const size = App.cellSize;
        for (const idx of App.selectedBlob) {
          const x = idx % width;
          const y = Math.floor(idx / width);
          ctx.fillRect(x * size, y * size, size, size);
        }
      }
    }

    // --- UI Bindings ---

    // --- UI Bindings ---

    function bindControls() {
      // --- Playback ---
      document.getElementById('play-pause').addEventListener('click', () => {
        App.playing = !App.playing;
        document.getElementById('play-pause').textContent = App.playing ? "Pause" : "Play";
      });

      document.getElementById('step-btn').addEventListener('click', () => {
        App.playing = false;
        document.getElementById('play-pause').textContent = "Play";
        App.sim.tick();
        App.buffer.push(App.sim.get_cells_ptr(), App.mem);
        draw();
        updateMeasurements();
      });

      document.getElementById('reset-btn').addEventListener('click', () => {
        App.sim.reset();
        draw();
      });

      document.getElementById('speed-slider').addEventListener('input', (e) => {
        const fps = parseInt(e.target.value);
        App.fpsInterval = 1000 / fps;
      });

      // --- Config / Update Order ---
      const updateConfig = () => {
        const sync = document.getElementById('sync-enabled').checked;
        const asyncRun = document.getElementById('async-enabled').checked;
        const order = document.querySelector('input[name="order"]:checked').value;
        const rate = parseFloat(document.getElementById('async-rate').value);
        App.sim.set_update_config(sync, asyncRun, order, rate);
      };

      document.getElementById('sync-enabled').addEventListener('change', updateConfig);
      document.getElementById('async-enabled').addEventListener('change', updateConfig);
      document.querySelectorAll('input[name="order"]').forEach(el => el.addEventListener('change', updateConfig));
      // async rate listeners
      const bindSync = (id1, id2, callback) => {
        const el1 = document.getElementById(id1);
        const el2 = document.getElementById(id2);
        el1.addEventListener('input', () => { el2.value = el1.value; callback(); });
        el2.addEventListener('input', () => { el1.value = el2.value; callback(); });
      };
      bindSync('async-rate', 'async-rate-num', updateConfig);

      // --- Ising Params ---
      const updateIsing = () => {
        const temp = parseFloat(document.getElementById('ising-temp').value);
        const h = parseFloat(document.getElementById('ising-h').value);
        const j = parseFloat(document.getElementById('ising-j').value);
        App.sim.set_ising_params(temp, h, j, "metropolis");
      };
      bindSync('ising-temp', 'ising-temp-range', updateIsing);
      bindSync('ising-h', 'ising-h-range', updateIsing);
      bindSync('ising-j', 'ising-j-range', updateIsing);

      // --- GoL Rules ---
      const updateGoL = () => {
        let birth = 0;
        let survival = 0;
        for (let i = 0; i <= 8; i++) {
          if (document.getElementById(`gol-b${i}`).checked) birth |= (1 << i);
          if (document.getElementById(`gol-s${i}`).checked) survival |= (1 << i);
        }
        App.sim.set_gol_rules(birth, survival);
      };
      for (let i = 0; i <= 8; i++) {
        document.getElementById(`gol-b${i}`).addEventListener('change', updateGoL);
        document.getElementById(`gol-s${i}`).addEventListener('change', updateGoL);
      }

      // --- Lattice / Scroll ---
      const updateBoundaries = () => {
        const mapVal = (val) => {
          if (val === 'fixed') return 1;
          if (val === 'reflect') return 2;
          if (val === 'absorbing') return 3;
          return 0; // periodic
        };
        const top = mapVal(document.getElementById('bound-top').value);
        const bottom = mapVal(document.getElementById('bound-bottom').value);
        const left = mapVal(document.getElementById('bound-left').value);
        const right = mapVal(document.getElementById('bound-right').value);
        const fixedVal = parseInt(document.getElementById('bound-fixed-val').value);

        App.sim.set_boundaries(top, bottom, left, right, fixedVal);
      };

      ['bound-top', 'bound-bottom', 'bound-left', 'bound-right', 'bound-fixed-val'].forEach(id => {
        document.getElementById(id).addEventListener('change', updateBoundaries);
      });

      const updateScroll = () => {
        const vx = parseFloat(document.getElementById('scroll-vx').value);
        const vy = parseFloat(document.getElementById('scroll-vy').value);
        App.sim.set_scroll_velocity(vx, vy);
      };
      bindSync('scroll-vx', 'scroll-vx-num', updateScroll);
      bindSync('scroll-vy', 'scroll-vy-num', updateScroll);

      // --- App / Display ---
      document.getElementById('density-select').addEventListener('change', (e) => {
        App.cellSize = parseInt(e.target.value);
        handleResize();
      });

      window.addEventListener('resize', handleResize);

      canvas.addEventListener('mousedown', handleCanvasClick);

      document.getElementById('btn-track').addEventListener('click', () => {
        if (App.selectedBlob) {
          runTracking();
        }
      });

      document.getElementById('export-glb').addEventListener('click', () => {
        if (window.lastScene) {
          exportToGLB(window.lastScene);
        }
      });

      // Tracking Frames Slider
      const trackSlider = document.getElementById('track-frames');
      const trackVal = document.getElementById('track-frames-val');
      trackSlider.addEventListener('input', () => {
        trackVal.textContent = trackSlider.value;
      });

      const voxelSlider = document.getElementById('max-voxels');
      const voxelVal = document.getElementById('max-voxels-val');
      voxelSlider.addEventListener('input', () => {
        let v = parseInt(voxelSlider.value);
        if (v >= 1000) {
          voxelVal.textContent = (v / 1000) + 'k';
        } else {
          voxelVal.textContent = v;
        }
      });

      document.getElementById('close-viewer').addEventListener('click', () => {
        document.getElementById('viewer-3d').style.display = 'none';
      });

      // --- Config Dump / Load Buttons ---
      document.getElementById('btn-dump-config').addEventListener('click', downloadConfig);
      document.getElementById('btn-load-config').addEventListener('click', uploadConfig);
      document.getElementById('btn-copy-config').addEventListener('click', copyConfig);
      document.getElementById('btn-copy-link').addEventListener('click', copyLink);
      document.getElementById('config-file-input').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          try {
            const cfg = JSON.parse(ev.target.result);
            loadConfig(cfg);
            showToast('Config loaded from ' + file.name);
          } catch (err) {
            showToast('Error: invalid config file');
            console.error('Config load error:', err);
          }
        };
        reader.readAsText(file);
        e.target.value = ''; // Reset so same file can be loaded again
      });

      // Initial setup calls
      updateConfig();
      updateIsing();
      updateGoL();
      updateBoundaries();
      updateScroll();
    }

    function handleResize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      canvas.width = w;
      canvas.height = h;

      App.width = Math.floor(w / App.cellSize);
      App.height = Math.floor(h / App.cellSize);

      if (App.sim) {
        App.sim.set_resolution(App.width, App.height);
        // Re-init buffer because dimensions changed
        App.buffer = new RollingBuffer(200, App.width, App.height);
        App.canvasBuffer.width = App.width;
        App.canvasBuffer.height = App.height;
        App.canvasContext = App.canvasBuffer.getContext('2d', { alpha: false });
        App.imgData = App.canvasContext.createImageData(App.width, App.height);
        ctx.imageSmoothingEnabled = false;
      }
      draw();
    }

    function updateMeasurements() {
      // We can call get_measurements from Rust
      // Sim has get_measurements() -> Vec<f64>
      // But returning Vec<f64> to JS results in Float64Array
      const m = App.sim.get_measurements();
      document.getElementById('meas-density').textContent = m[0].toFixed(3);
      document.getElementById('meas-mag').textContent = m[1].toFixed(3);
      document.getElementById('meas-energy').textContent = m[2].toFixed(2);
    }

    function updateHistoryStats() {
      if (App.buffer) {
        document.getElementById('hist-count').textContent = App.buffer.count;
      }
    }

    function handleCanvasClick(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      const x = Math.floor(mx / App.cellSize);
      const y = Math.floor(my / App.cellSize);

      const idx = y * App.width + x;

      // Get current frame
      const ptr = App.sim.get_cells_ptr();
      const cells = new Int32Array(App.mem.buffer, ptr, App.width * App.height);

      // Flood fill to find component
      const component = getConnectedComponent(cells, idx, App.width, App.height);

      if (component.size > 0) {
        App.selectedBlob = component;
        document.getElementById('sel-info').textContent = `Selected size: ${component.size}`;
        document.getElementById('btn-track').disabled = false;
        draw();
      } else {
        App.selectedBlob = null;
        document.getElementById('sel-info').textContent = "No blob selected";
        document.getElementById('btn-track').disabled = true;
        draw();
      }
    }

    function runTracking() {
      App.playing = false; // Pause

      const maxFrames = parseInt(document.getElementById('track-frames').value);
      const maxVoxels = parseInt(document.getElementById('max-voxels').value);

      // 1. Trace Backward
      const back = traceBackward(App.buffer, App.selectedBlob, App.width, App.height, maxFrames);

      // 2. Trace Forward
      const fwd = traceForward(App.sim, App.selectedBlob, maxFrames); // Use visual slider val

      // 3. Render
      const scene = renderSpacetimeStructure(back, fwd, App.width, App.height, maxVoxels);
      window.lastScene = scene; // Store for export

      // Show Viewer
      const viewer = document.getElementById('viewer-3d');
      viewer.style.display = 'flex';

      init3D(scene);
    }

    function init3D(structureGroup) {
      const container = document.getElementById('container-3d');
      const viewer = document.getElementById('viewer-3d');
      container.innerHTML = ''; // Clear previous

      const w = container.clientWidth;
      const h = container.clientHeight;

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x222222);

      const camera = new THREE.PerspectiveCamera(75, w / h, 0.1, 1000);
      camera.position.set(0, 0, 100);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(w, h);
      container.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);

      // Lighting
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(1, 1, 1).normalize();
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x404040));

      // Add structure
      scene.add(structureGroup);

      // Resize handler for 3D
      const resizeObserver = new ResizeObserver(() => {
        const wn = container.clientWidth;
        const hn = container.clientHeight;
        renderer.setSize(wn, hn);
        camera.aspect = wn / hn;
        camera.updateProjectionMatrix();
      });
      resizeObserver.observe(container);

      function animate() {
        if (viewer.style.display === 'none') return;
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
    }

    // --- Config Dump / Load ---

    function showToast(msg) {
      const el = document.getElementById('toast');
      el.textContent = msg;
      el.classList.add('show');
      setTimeout(() => el.classList.remove('show'), 2000);
    }

    function dumpConfig() {
      const birth = [];
      const survival = [];
      for (let i = 0; i <= 8; i++) {
        if (document.getElementById(`gol-b${i}`).checked) birth.push(i);
        if (document.getElementById(`gol-s${i}`).checked) survival.push(i);
      }

      return {
        _version: 1,
        _timestamp: new Date().toISOString(),
        ising: {
          enabled: document.getElementById('async-enabled').checked,
          temperature: parseFloat(document.getElementById('ising-temp').value),
          field_h: parseFloat(document.getElementById('ising-h').value),
          coupling_j: parseFloat(document.getElementById('ising-j').value),
          sweeps_per_frame: parseFloat(document.getElementById('async-rate').value),
        },
        gol: {
          enabled: document.getElementById('sync-enabled').checked,
          birth: birth,
          survival: survival,
        },
        lattice: {
          boundaries: {
            top: document.getElementById('bound-top').value,
            bottom: document.getElementById('bound-bottom').value,
            left: document.getElementById('bound-left').value,
            right: document.getElementById('bound-right').value,
          },
          fixed_value: parseInt(document.getElementById('bound-fixed-val').value),
          scroll_vx: parseFloat(document.getElementById('scroll-vx').value),
          scroll_vy: parseFloat(document.getElementById('scroll-vy').value),
        },
        update_order: document.querySelector('input[name="order"]:checked').value,
        display: {
          density: parseInt(document.getElementById('density-select').value),
          speed_fps: parseInt(document.getElementById('speed-slider').value),
        },
      };
    }

    function loadConfig(cfg) {
      if (!cfg || typeof cfg !== 'object') return;

      // Ising
      if (cfg.ising) {
        if (cfg.ising.enabled !== undefined) document.getElementById('async-enabled').checked = cfg.ising.enabled;
        if (cfg.ising.temperature !== undefined) {
          document.getElementById('ising-temp').value = cfg.ising.temperature;
          document.getElementById('ising-temp-range').value = cfg.ising.temperature;
        }
        if (cfg.ising.field_h !== undefined) {
          document.getElementById('ising-h').value = cfg.ising.field_h;
          document.getElementById('ising-h-range').value = cfg.ising.field_h;
        }
        if (cfg.ising.coupling_j !== undefined) {
          document.getElementById('ising-j').value = cfg.ising.coupling_j;
          document.getElementById('ising-j-range').value = cfg.ising.coupling_j;
        }
        if (cfg.ising.sweeps_per_frame !== undefined) {
          document.getElementById('async-rate').value = cfg.ising.sweeps_per_frame;
          document.getElementById('async-rate-num').value = cfg.ising.sweeps_per_frame;
        }
      }

      // GoL
      if (cfg.gol) {
        if (cfg.gol.enabled !== undefined) document.getElementById('sync-enabled').checked = cfg.gol.enabled;
        if (cfg.gol.birth) {
          for (let i = 0; i <= 8; i++) {
            document.getElementById(`gol-b${i}`).checked = cfg.gol.birth.includes(i);
          }
        }
        if (cfg.gol.survival) {
          for (let i = 0; i <= 8; i++) {
            document.getElementById(`gol-s${i}`).checked = cfg.gol.survival.includes(i);
          }
        }
      }

      // Lattice
      if (cfg.lattice) {
        if (cfg.lattice.boundaries) {
          const b = cfg.lattice.boundaries;
          if (b.top) document.getElementById('bound-top').value = b.top;
          if (b.bottom) document.getElementById('bound-bottom').value = b.bottom;
          if (b.left) document.getElementById('bound-left').value = b.left;
          if (b.right) document.getElementById('bound-right').value = b.right;
        }
        if (cfg.lattice.fixed_value !== undefined) document.getElementById('bound-fixed-val').value = cfg.lattice.fixed_value;
        if (cfg.lattice.scroll_vx !== undefined) {
          document.getElementById('scroll-vx').value = cfg.lattice.scroll_vx;
          document.getElementById('scroll-vx-num').value = cfg.lattice.scroll_vx;
        }
        if (cfg.lattice.scroll_vy !== undefined) {
          document.getElementById('scroll-vy').value = cfg.lattice.scroll_vy;
          document.getElementById('scroll-vy-num').value = cfg.lattice.scroll_vy;
        }
      }

      // Update order
      if (cfg.update_order) {
        const radio = document.querySelector(`input[name="order"][value="${cfg.update_order}"]`);
        if (radio) radio.checked = true;
      }

      // Display
      if (cfg.display) {
        if (cfg.display.density !== undefined) {
          document.getElementById('density-select').value = cfg.display.density;
          App.cellSize = cfg.display.density;
          handleResize();
        }
        if (cfg.display.speed_fps !== undefined) {
          document.getElementById('speed-slider').value = cfg.display.speed_fps;
          App.fpsInterval = 1000 / cfg.display.speed_fps;
        }
      }

      // Push everything to the simulation
      // Re-use the existing update functions by triggering them
      const sync = document.getElementById('sync-enabled').checked;
      const asyncRun = document.getElementById('async-enabled').checked;
      const order = document.querySelector('input[name="order"]:checked').value;
      const rate = parseFloat(document.getElementById('async-rate').value);
      App.sim.set_update_config(sync, asyncRun, order, rate);

      const temp = parseFloat(document.getElementById('ising-temp').value);
      const h = parseFloat(document.getElementById('ising-h').value);
      const j = parseFloat(document.getElementById('ising-j').value);
      App.sim.set_ising_params(temp, h, j, "metropolis");

      let birth = 0;
      let survival = 0;
      for (let i = 0; i <= 8; i++) {
        if (document.getElementById(`gol-b${i}`).checked) birth |= (1 << i);
        if (document.getElementById(`gol-s${i}`).checked) survival |= (1 << i);
      }
      App.sim.set_gol_rules(birth, survival);

      const mapVal = (val) => {
        if (val === 'fixed') return 1;
        if (val === 'reflect') return 2;
        if (val === 'absorbing') return 3;
        return 0;
      };
      App.sim.set_boundaries(
        mapVal(document.getElementById('bound-top').value),
        mapVal(document.getElementById('bound-bottom').value),
        mapVal(document.getElementById('bound-left').value),
        mapVal(document.getElementById('bound-right').value),
        parseInt(document.getElementById('bound-fixed-val').value)
      );

      App.sim.set_scroll_velocity(
        parseFloat(document.getElementById('scroll-vx').value),
        parseFloat(document.getElementById('scroll-vy').value)
      );
    }

    function downloadConfig() {
      const cfg = dumpConfig();
      const json = JSON.stringify(cfg, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `lattice-config-${new Date().toISOString().slice(0, 19).replace(/:/g, '')}.json`;
      a.click();
      URL.revokeObjectURL(url);
      showToast('Config saved to file');
    }

    function copyConfig() {
      const cfg = dumpConfig();
      const json = JSON.stringify(cfg, null, 2);
      navigator.clipboard.writeText(json).then(() => {
        showToast('Config copied to clipboard');
      }).catch(() => {
        // Fallback: select-all in a textarea
        const ta = document.createElement('textarea');
        ta.value = json;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        showToast('Config copied to clipboard');
      });
    }

    function copyLink() {
      const cfg = dumpConfig();
      const json = JSON.stringify(cfg);
      const encoded = btoa(unescape(encodeURIComponent(json)));
      const url = window.location.origin + window.location.pathname + '#config=' + encoded;
      navigator.clipboard.writeText(url).then(() => {
        showToast('Link copied to clipboard');
      }).catch(() => {
        const ta = document.createElement('textarea');
        ta.value = url;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        showToast('Link copied to clipboard');
      });
    }

    function loadConfigFromURL() {
      const hash = window.location.hash;
      if (!hash.startsWith('#config=')) return;
      try {
        const encoded = hash.slice('#config='.length);
        const json = decodeURIComponent(escape(atob(encoded)));
        const cfg = JSON.parse(json);
        loadConfig(cfg);
        showToast('Config loaded from URL');
      } catch (e) {
        console.warn('Failed to load config from URL:', e);
      }
    }

    function uploadConfig() {
      document.getElementById('config-file-input').click();
    }

    // --- Sidebar Logic ---
    function initSidebar() {
      const toggleBtn = document.getElementById('sidebar-toggle');
      const sidebar = document.getElementById('sidebar-container');
      const container = document.getElementById('sidebar-content');
      toggleBtn.addEventListener('click', () => {
        sidebar.classList.toggle('collapsed');
      });
    }

    // --- Global Keys ---
    function initInputs() {
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          App.playing = !App.playing;
          document.getElementById('play-pause').textContent = App.playing ? "Pause" : "Play";
        }
        // Ctrl+S: save config
        if ((e.ctrlKey || e.metaKey) && e.code === 'KeyS') {
          e.preventDefault();
          downloadConfig();
        }
        // Ctrl+O: load config
        if ((e.ctrlKey || e.metaKey) && e.code === 'KeyO') {
          e.preventDefault();
          uploadConfig();
        }
      });
    }

    // Run UI Init
    initSidebar();
    initInputs();
  </script>
<script>"use strict";

(function () {

    const address = '{{__TRUNK_ADDRESS__}}';
    const base = '{{__TRUNK_WS_BASE__}}';
    let protocol = '';
    protocol =
        protocol
            ? protocol
            : window.location.protocol === 'https:'
                ? 'wss'
                : 'ws';
    const url = protocol + '://' + address + base + '.well-known/trunk/ws';

    class Overlay {
        constructor() {
            // create an overlay
            this._overlay = document.createElement("div");
            const style = this._overlay.style;
            style.height = "100vh";
            style.width = "100vw";
            style.position = "fixed";
            style.top = "0";
            style.left = "0";
            style.backgroundColor = "rgba(222, 222, 222, 0.5)";
            style.fontFamily = "sans-serif";
            // not sure that's the right approach
            style.zIndex = "1000000";
            style.backdropFilter = "blur(1rem)";

            const container = document.createElement("div");
            // center it
            container.style.position = "absolute";
            container.style.top = "30%";
            container.style.left = "15%";
            container.style.maxWidth = "85%";

            this._title = document.createElement("div");
            this._title.innerText = "Build failure";
            this._title.style.paddingBottom = "2rem";
            this._title.style.fontSize = "2.5rem";

            this._message = document.createElement("div");
            this._message.style.whiteSpace = "pre-wrap";

            const icon= document.createElement("div");
            icon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="#dc3545" viewBox="0 0 16 16"><path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/></svg>';
            this._title.prepend(icon);

            container.append(this._title, this._message);
            this._overlay.append(container);

            this._inject();
            window.setInterval(() => {
                this._inject();
            }, 250);
        }

        set reason(reason) {
            this._message.textContent = reason;
        }

        _inject() {
            if (!this._overlay.isConnected) {
                // prepend it
                document.body?.prepend(this._overlay);
            }
        }

    }

    class Client {
        constructor(url) {
            this.url = url;
            this.poll_interval = 5000;
            this._overlay = null;
        }

        start() {
            const ws = new WebSocket(this.url);
            ws.onmessage = (ev) => {
                const msg = JSON.parse(ev.data);
                switch (msg.type) {
                    case "reload":
                        this.reload();
                        break;
                    case "buildFailure":
                        this.buildFailure(msg.data)
                        break;
                }
            };
            ws.onclose = () => this.onclose();
        }

        onclose() {
            window.setTimeout(
                () => {
                    // when we successfully reconnect, we'll force a
                    // reload (since we presumably lost connection to
                    // trunk due to it being killed, so it will have
                    // rebuilt on restart)
                    const ws = new WebSocket(this.url);
                    ws.onopen = () => window.location.reload();
                    ws.onclose = () => this.onclose();
                },
                this.poll_interval);
        }

        reload() {
            window.location.reload();
        }

        buildFailure({reason}) {
            // also log the console
            console.error("Build failed:", reason);

            console.debug("Overlay", this._overlay);

            if (!this._overlay) {
                this._overlay = new Overlay();
            }
            this._overlay.reason = reason;
        }
    }

    new Client(url).start();

})()
</script></body>

</html>