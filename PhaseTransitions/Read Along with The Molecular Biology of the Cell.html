<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>read-along-with-the-molecular-biology-of-the-cell – Fergus Fettes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-e73ed75cf5e7a3fd855296a79e6d84f7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Fergus Fettes</span>
    </a>
  </div>
          <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
            <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<blockquote class="blockquote">
<p>But they have removed the central mystery regarding the nature of life. We can now see that all living things are made of cells: small, membrane-enclosed units filled with a concentrated aqueous solution of chemicals and endowed with the extraordinary ability to create copies of themselves by growing and then dividing in two.</p>
</blockquote>
<p>‘all living things are made of cells’ while interesting, is not the core mystery of life</p>
<p>cell division is a candidate for a step</p>
<blockquote class="blockquote">
<p>viruses, the ubiquitous parasites that have evolved to feed on cells. Viruses are now recognized to be the most abundant biological entities on the planet.</p>
</blockquote>
<p>poor framing. viruses are non-cooperating replicators. they are the model for humanities continued survival</p>
<blockquote class="blockquote">
<p>Thus, the parent organism hands down information specifying, in extraordinary detail, the characteristics that the offspring will have. This phenomenon of heredity is central to the definition of life: it distinguishes life from other processes, such as the growth of a crystal, or the burning of a candle, or the formation of waves on water, in which structures are generated without the same type of link between the peculiarities of parents and offspring.</p>
</blockquote>
<p>poor framing. the key is a product of the long-term stability of the different data-structures/information systems, and their size/complexity. a flame is a very simple but potentially long-lasting sytem. actually the chemical processes are active in all our cells, so this is hardly a counterexample, its just a macroscopic manifestation of the same chemical processes that drive life</p>
<blockquote class="blockquote">
<p>One might not expect that they would all store their information in the same form or that the hereditary information carried by one type of cell should be readable by the information-handling machinery of another. And yet it is so. is fact pro- vides compelling evidence that all living things on Earth have inherited the form of their genetic instructions, as well as how to use them, from a universal com- mon ancestral cell. is ancestor is thought to have existed roughly 3.5–3.8 billion years ago.</p>
</blockquote>
<p>doubt it lol</p>
<p>but this is remarkable no doubt. there is only ‘one way to fold a protein’. there is only ‘one way to split a cell’ ??. but there should be many ways to store the information. this does indicate a universal common ancestor– and it also indicates one of two other things: - either there is a weirdly strong evolutionary pressure to centralize the information storage method - or, life on earth is a random sample of different methods (which came in from space)</p>
<p>absent a candidate for 1, i am assuming 2</p>
<blockquote class="blockquote">
<p>e mechanisms that make life possible depend on the structure of the double-strand DNA molecule.</p>
</blockquote>
<p>Fine, but there are tonnes of details about DNA structure which I think are largely contingent and irrelevant for my purposes.</p>
<p>And a lot of the simplifications they make for the sake of their story of genetics are simply false, eg:</p>
<blockquote class="blockquote">
<p>the information is always “read” in a consistent order, just as written English text is read from left to right</p>
</blockquote>
<p>however, maybe there is something significant about the double-helix. to whit: - proteins pattern-match - rna is programmable pattern matching (why? reducing the choice of amino acids stabilizes the phase space and the combinatorics) - dna is pattern-matched! this has two effects: - - it can be turned on and off - - it is more stable both of these things are crucial!</p>
<p>now, stability can be had in rna with lots of junk. but the symmetry of matching has two effects: it makes a backup of the data, and it results in the maximum stability per atom</p>
<p>this is looking strongly emergent though– different things become possible for every increase in rna length. so you just want to increase rna length and things will happen</p>
<p>but i can have my cake and eat it– the evolutionary process can be strongly emergent, but they later higher-orders of organization back-port more optimal patterns, pushing out intermediates. so long strands of RNA which evolved for stability get pushed out by DNA which does it better for less and has a second copy of the gene as a bonus.</p>
<blockquote class="blockquote">
<p>The two strands twist around each other to form a double helix—a robust structure that can accommodate any sequence of nucleotides without altering its basic double-helical structure</p>
</blockquote>
<p>but they do alter its higher-order structure!</p>
<blockquote class="blockquote">
<p>DNA is the information store for heredity, and templated polymerization is the way in which this information is copied throughout the living world.</p>
</blockquote>
<p>templated polymerization is just a fancy word for the pattern-matching i was talking about, which is the same mechanism that drives protein folding. okay in this case its a highly-complex process mediated by lots of other proteins etc. actually, it is different– otherwise you could say ‘all protein interactions are small instances of loose pattern-matching in a large network of energetic influences’. though maybe you do want to say that.</p>
<p>but if it is just a higher-order of the same– its a spreading of the markov blanket? the markov blanket of dna replication includes a lot of protiens.</p>
<p>so again this is just programmable pattern matching. but wait! what does that mean? i really mean that the markov blanket is spread over a loose collection of molecules, the interactions between which are ordered on larger timescales. that is what programmable means!</p>
<p>hold on– what about the argument about maths and brain states? i was grasping at the algorithm having an independent existence? but if programmable matter is just matter orchestrated (coherent over longer timescales) does that mean the math algorithm is something similar? it presumably is just brain states. but the way that different ‘math algorithm’ brain states evolve depends on different dynamics than the way that ‘language algorithm’ brain states evolve, dynamics which are encoded in a neural net. the neural net is ‘multimodal’, it has abstracted different kinds of algorithms.</p>
<blockquote class="blockquote">
<p>two other crucial classes of biological polymers: RNA molecules and protein molecules.</p>
</blockquote>
<p>recapitulating evolution in reverse, as allways. increasingly fine-grained, increasingly many conformational states. worth noting that proteins are not arbitrary either, they collapse the space of possible chemicals to a useful set.</p>
<p>the dual use nature of RNA leads to an accounting problem, DNA solves this. this leads to better morphological stability</p>
<blockquote class="blockquote">
<p>messenger RNA (mRNA) molecules that guide the synthesis of proteins according to the genetic instructions stored in the DNA.</p>
</blockquote>
<p>presumably also according to the chemical gradients in the environment– the one-to-many nature of dna transcription is critical– who mediates the number of copies produced?</p>
<p>this is just a manifestation of heredity– one-to-many! unlike RNA which are both hereditary information and product, DNA is a pure carrier, so you have abstracted away the source.</p>
<p>to clarify: - strong (DNA) heredity allows long-term storage - long-term storage also allows for many copies - many copies means there is a pressure for optimization - which results in the evolution of mechanisms to control expression - in the end, fine-grained gene expression control allows for the control of morphology</p>
<blockquote class="blockquote">
<p>Proteins form and maintain diverse cell and extracellular structures, generate movements, sense signals, and so on.</p>
</blockquote>
<p>lol, go off</p>
<blockquote class="blockquote">
<p>But in chemistry, the term catalyst is defined more narrowly, being applied to any molecule that speeds up a specific chemical reaction without itself being changed. From the most fundamental point of view, a living cell is a self-replicating collection of catalysts that takes in food, processes this food to provide both the building blocks and energy needed to make more catalysts, and discards the materials left over as waste</p>
</blockquote>
<p>cool, but this is a bit like Turings ‘morphogen’ definition, maybe a bit too broad to be useful.</p>
<p>I’m looking for a more concrete breakdown, something like - catalysis of chemical bonds, like ADP-ATP - stabilization of molecules, like the protein module that holds ADP in place to get catalyzed - transport of molecules, like the proteins that ferry nucleotides to the ribosome - stabilization/transport of protiens– this higher-order stabilization is harder to characterize, systems-level stuff. could be many levels. remember that DNA and other big macromolecules will eventually make up part of this structure as well</p>
<p>per the definition, all of these could be called catalysts, inasmuch as they ultimately speed up the rate of catalysis?</p>
<blockquote class="blockquote">
<p>Life as an autocatalytic process. (A) The living cell is a self-replicating collection of catalysts.</p>
</blockquote>
<p>you could say the same thing about morphology or heomeostatic loops, not sure how useful this is. ‘an autocatalytic process’ is also a markov blanket, finding the boundaries is still hard</p>
<blockquote class="blockquote">
<p>These arbitrary features, it is thought, reflect frozen accidents in the early history of life.</p>
</blockquote>
<p>yessir. and figuring out which parts are contingent snapshots and which are inevitable is the name of the game</p>
<blockquote class="blockquote">
<p>each triplet of nucleotides, or codon</p>
</blockquote>
<p>this, for example let me declare, is a topic of no importance, just striking the optimal balance between the combinatorics of the nucleotides, the stability requirements, and the number of amino acids– in other setups the tradeoff would be different, but the mechanism of the tradeoff here is not crucial, it is just finetuning.</p>
<p>whatever inefficiency there is here will be paid out via overloading</p>
<blockquote class="blockquote">
<p>And individual segments of the long DNA sequence are transcribed into separate mRNA molecules, coding for different proteins. Each such DNA segment represents one gene … stretches of regulatory DNA are interspersed among the segments that code for protein, and these noncoding regions bind to special protein molecules that control the rate of transcription of individual genes.</p>
</blockquote>
<p>notice the contradiction here? regulatory DNA puts the lie to the idea that genes are straightforwardly expressed in stretches of DNA</p>
<p>this is important because you want to develop on your intuition for functional overloading at every opportunity</p>
<blockquote class="blockquote">
<p>Life Requires a Continual Input of Free Energy</p>
</blockquote>
<p>anything worth saying about this stage? should get into the jeremy england stuff, but the core idea that its all whorls on a entropy gradient is well enough etablished i think</p>
<blockquote class="blockquote">
<p>All Cells Function as Biochemical Factories</p>
</blockquote>
<p>not sure how this section differs from the previous one, its just a layer of obfuscation</p>
<blockquote class="blockquote">
<p>Without a plasma membrane, the cell could not maintain its integrity as a coordinated chemical system.</p>
</blockquote>
<p>yes. the first steps of identity and selfish cooperation</p>
<p>also a convenient markov measurement stage, as well as energy-rate density. probably this is the best thing about cells– how they simplify our calculations!</p>
<blockquote class="blockquote">
<p>cells produce molecules whose chemical properties cause them to self-assemble into the structures that a cell needs.</p>
</blockquote>
<p>no! you got it backwards! molecules with the tendency to self-assemble produce cells</p>
<p>this is great though. where to place this? its a macroscopic manifestation of a low-level process. what is the markov blanket of a cell wall? does it have one? is a cell wall a thing? i guess there would be a coherence length to its fluctuations, maybe you can concretize the markov blanket to some moderate number of interacting phospholipids?</p>
<blockquote class="blockquote">
<p>Some of these membrane transport proteins, like some of the proteins that catalyze the fundamental small-molecule reactions inside the cell, have been so well conserved over the course of evolution that we can recognize the fam- ily resemblances between them when even the most distantly related organisms are compared.</p>
</blockquote>
<p>good to know. maybe membrane transport is very high in the list</p>
<blockquote class="blockquote">
<p>Thus, by specifying the RNAs and proteins that the cell produces, the genetic information recorded in the DNA sequence dictates the entire chemistry of the cell—in fact, not only its chemistry but also its form and its behavior, for these too are chiefly determined and controlled by the cell’s proteins.</p>
</blockquote>
<p>nope. all cells are seeded with a structure (molecular composition) which partially determines expression. you can knock an entire lineage into a different morphology without changing the DNA.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p><a href="https://www.quarto.org">Quarto</a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/FergusFettes">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>